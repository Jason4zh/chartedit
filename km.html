<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhigrosæŒ‰é”®è½¬æ¢å™¨</title>
    <link rel="stylesheet" href="common.css">
    <style>
        .upload-area:active { transform: scale(0.98); }
        .upload-area.dragging { background: #e3f2fd; border-color: #2196f3; }
        .format-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; }
        .format-rpe { background: #e3f2fd; color: #1976d2; }
        .format-phi { background: #f3e5f5; color: #7b1fa2; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PhigrosæŒ‰é”®è½¬æ¢å™¨</h1>
        </header>
        
        <div class="main-content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <p>æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ Phigrosè°±é¢ZIPæ–‡ä»¶</p>
                <input type="file" id="fileInput" accept=".zip" style="display: none;">
            </div>
            
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <p>æ­£åœ¨è§£æè°±é¢ç»“æ„...</p>
            </div>
            
            <div class="controls-section" id="controlsSection" style="display: none;">
                <div class="file-info" id="fileInfo">
                    <div class="info-item">
                        <span>æ–‡ä»¶:</span>
                        <span id="fileName">-</span>
                    </div>
                    <div class="info-item">
                        <span>æŒ‰é”®æ•°:</span>
                        <span id="noteCount">-</span>
                    </div>
                    <div class="info-item">
                        <span>æ ¼å¼:</span>
                        <span id="chartFormat">-</span>
                    </div>
                    <div class="info-item">
                        <span>ç‰ˆæœ¬:</span>
                        <span id="formatVersion">-</span>
                    </div>
                    <div class="info-item">
                        <span>åˆ¤å®šçº¿:</span>
                        <span id="judgeLineCount">-</span>
                    </div>
                </div>
                
                <div class="conversion-controls">
                    <div class="conversion-options">
                        <button class="conversion-btn" data-type="tap">Tap</button>
                        <button class="conversion-btn" data-type="drag">Drag</button>
                        <button class="conversion-btn" data-type="hold">Hold</button>
                        <button class="conversion-btn" data-type="flick">Flick</button>
                    </div>
                    
                    <div class="hold-controls" id="holdControls">
                        <div class="hold-option">
                            <input type="checkbox" id="includeHold" checked>
                            <label for="includeHold">åŒ…å«HoldéŸ³ç¬¦</label>
                        </div>
                        <div class="hold-length" id="holdLengthControl">
                            <label>Holdé•¿åº¦:</label>
                            <input type="number" id="holdLength" value="200" min="50" max="2000" step="50">
                            <span>ms</span>
                        </div>
                    </div>
                </div>
                
                <button class="download-btn" id="downloadBtn" disabled>
                    ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶
                </button>
                
                <div class="status" id="status" style="display: none;"></div>
                
                <div class="debug-info" id="debugInfo" style="display: none; margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 500px; overflow-y: auto;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">è°ƒè¯•ä¿¡æ¯</h4>
                    <div id="debugContent"></div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>æœ¬å·¥å…·å®Œå…¨åœ¨æµè§ˆå™¨ä¸­è¿è¡Œï¼Œä¸ä¼šä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨</p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // ==================== å…¨å±€å˜é‡ ====================
        let originalZip = null;
        let jsonFileName = null;
        let chartData = null;
        let chartFormat = null; // 'rpe' æˆ– 'phi'
        let selectedType = 'tap';
        let originalFileName = '';
        let isProcessing = false;

        // ==================== DOMå…ƒç´  ====================
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const loading = document.getElementById('loading');
        const controlsSection = document.getElementById('controlsSection');
        const downloadBtn = document.getElementById('downloadBtn');
        const status = document.getElementById('status');
        const debugInfo = document.getElementById('debugInfo');
        const debugContent = document.getElementById('debugContent');
        
        // ä¿¡æ¯å±•ç¤ºåŒº
        const fileNameSpan = document.getElementById('fileName');
        const noteCountSpan = document.getElementById('noteCount');
        const chartFormatSpan = document.getElementById('chartFormat');
        const formatVersionSpan = document.getElementById('formatVersion');
        const judgeLineCountSpan = document.getElementById('judgeLineCount');

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            // ç‚¹å‡»ä¸Šä¼ 
            uploadArea.addEventListener('click', () => fileInput.click());
            
            // æ–‡ä»¶é€‰æ‹©
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
            
            // æ‹–æ‹½ä¸Šä¼ 
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragging');
                if (e.dataTransfer.files.length > 0) {
                    handleFileUpload(e.dataTransfer.files[0]);
                }
            });
            
            // è½¬æ¢æŒ‰é’®
            document.querySelectorAll('.conversion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.conversion-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedType = this.dataset.type;
                    
                    // Holdæ§åˆ¶æ˜¾ç¤º/éšè—
                    const holdLengthControl = document.getElementById('holdLengthControl');
                    const includeHoldCheck = document.getElementById('includeHold');
                    if (selectedType === 'hold') {
                        holdLengthControl.style.display = 'flex';
                        includeHoldCheck.style.display = 'none';
                    } else {
                        holdLengthControl.style.display = 'none';
                        includeHoldCheck.style.display = 'flex';
                    }
                });
            });
            
            // é»˜è®¤é€‰æ‹©Tap
            document.querySelector('.conversion-btn[data-type="tap"]').click();
            
            // ä¸‹è½½æŒ‰é’®
            downloadBtn.addEventListener('click', downloadConvertedZip);
        }

        // ==================== æ ¼å¼æ£€æµ‹ ====================
        /**
         * ä¸¥æ ¼åˆ¤æ–­è°±é¢æ ¼å¼
         * RPEæ ¼å¼ç‰¹å¾ï¼šBPMList + judgeLineList.notesAbove/Below
         * å®˜æ–¹æ ¼å¼ç‰¹å¾ï¼šformatVersion + noteList
         */
        function determineChartFormat(data) {
            // ===== RPEæ ¼å¼æ£€æµ‹ =====
            if (data.BPMList && Array.isArray(data.BPMList)) {
                if (data.judgeLineList && Array.isArray(data.judgeLineList)) {
                    // éªŒè¯ç¬¬ä¸€æ¡åˆ¤å®šçº¿ç»“æ„
                    if (data.judgeLineList.length > 0) {
                        const firstLine = data.judgeLineList[0];
                        if (firstLine.hasOwnProperty('notesAbove') || firstLine.hasOwnProperty('notesBelow')) {
                            return 'rpe';
                        }
                    }
                }
            }
            
            // ===== å®˜æ–¹æ ¼å¼æ£€æµ‹ =====
            if (data.formatVersion !== undefined && data.noteList && Array.isArray(data.noteList)) {
                // éªŒè¯éŸ³ç¬¦ç»“æ„
                if (data.noteList.length > 0) {
                    const firstNote = data.noteList[0];
                    if (firstNote.hasOwnProperty('type') && firstNote.hasOwnProperty('time') && firstNote.hasOwnProperty('judgeLine')) {
                        return 'phi';
                    }
                } else {
                    // ç©ºnoteListä¹Ÿè®¤ä¸ºæ˜¯å®˜æ–¹æ ¼å¼
                    return 'phi';
                }
            }
            
            return 'unknown';
        }

        // ==================== Typeæ˜ å°„ ====================
        /**
         * UIç±»å‹å -> æ ¼å¼ç‰¹å®šçš„æ•°å€¼
         * RPE: 1=Tap, 2=Hold, 3=Flick, 4=Drag
         * å®˜æ–¹: 1=Tap, 2=Drag, 3=Hold, 4=Flick
         */
        function getFormatTypeValue(format, uiType) {
            const mapping = {
                rpe: { tap: 1, hold: 2, flick: 3, drag: 4 },
                phi: { tap: 1, drag: 2, hold: 3, flick: 4 }
            };
            return mapping[format][uiType];
        }

        /**
         * æ•°å€¼ -> æ˜¾ç¤ºåç§°ï¼ˆç”¨äºè°ƒè¯•ï¼‰
         */
        function getTypeName(format, typeValue) {
            const mapping = {
                rpe: { 1: 'Tap', 2: 'Hold', 3: 'Flick', 4: 'Drag' },
                phi: { 1: 'Tap', 2: 'Drag', 3: 'Hold', 4: 'Flick' }
            };
            return mapping[format][typeValue] || `Unknown(${typeValue})`;
        }

        // ==================== æ–‡ä»¶ä¸Šä¼  ====================
        async function handleFileUpload(file) {
            if (isProcessing) return;
            
            // éªŒè¯æ–‡ä»¶
            if (!file || !file.name.toLowerCase().endsWith('.zip')) {
                showStatus('è¯·ä¸Šä¼ ZIPæ–‡ä»¶', 'error');
                return;
            }
            
            if (file.size === 0) {
                showStatus('æ–‡ä»¶ä¸ºç©º', 'error');
                return;
            }
            
            isProcessing = true;
            loading.classList.add('show');
            debugInfo.style.display = 'block';
            showDebugInfo('æ–‡ä»¶ä¿¡æ¯', [
                `åç§°: ${file.name}`,
                `å¤§å°: ${(file.size / 1024).toFixed(2)} KB`
            ]);
            
            try {
                // è¯»å–ZIP
                const arrayBuffer = await file.arrayBuffer();
                originalZip = await JSZip.loadAsync(arrayBuffer);
                
                // æŸ¥æ‰¾JSONæ–‡ä»¶
                const jsonFiles = [];
                originalZip.forEach((relativePath, fileEntry) => {
                    if (!fileEntry.dir && relativePath.toLowerCase().endsWith('.json')) {
                        jsonFiles.push(relativePath);
                    }
                });
                
                if (jsonFiles.length === 0) {
                    throw new Error('ZIPä¸­æœªæ‰¾åˆ°JSONæ–‡ä»¶');
                }
                
                jsonFileName = jsonFiles[0];
                originalFileName = file.name.replace(/\.zip$/i, '');
                
                // è¯»å–JSON
                const jsonFile = originalZip.file(jsonFileName);
                const jsonText = await jsonFile.async('text');
                chartData = JSON.parse(jsonText);
                
                // æ£€æµ‹æ ¼å¼
                chartFormat = determineChartFormat(chartData);
                if (chartFormat === 'unknown') {
                    throw new Error('æ— æ³•è¯†åˆ«æ ¼å¼ï¼šç¼ºå°‘BPMList(RPE)æˆ–formatVersion(å®˜æ–¹)');
                }
                
                // ç»Ÿè®¡ä¿¡æ¯
                const noteCount = countNotes(chartData, chartFormat);
                const judgeLineCount = getJudgeLineCount(chartData, chartFormat);
                
                // æ›´æ–°UI
                fileNameSpan.textContent = file.name;
                noteCountSpan.textContent = noteCount;
                chartFormatSpan.innerHTML = `<span class="format-badge format-${chartFormat}">${chartFormat === 'rpe' ? 'RPEæ ¼å¼' : 'å®˜æ–¹æ ¼å¼'}</span>`;
                formatVersionSpan.textContent = chartData.formatVersion || chartData.rpeVersion || '--';
                judgeLineCountSpan.textContent = judgeLineCount;
                
                // åˆ†æç»“æ„
                analyzeChartStructure(chartData, chartFormat);
                
                // æ˜¾ç¤ºæ§åˆ¶é¢æ¿
                controlsSection.style.display = 'block';
                downloadBtn.disabled = false;
                
                showStatus('è°±é¢åŠ è½½æˆåŠŸ', 'success');
                
            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                showStatus('åŠ è½½å¤±è´¥: ' + error.message, 'error');
                showDebugInfo('é”™è¯¯è¯¦æƒ…', [
                    `é”™è¯¯: ${error.message}`,
                    `å †æ ˆ: ${error.stack || 'æ— '}`
                ]);
                
                // é‡ç½®
                controlsSection.style.display = 'none';
                downloadBtn.disabled = true;
                
            } finally {
                loading.classList.remove('show');
                isProcessing = false;
            }
        }

        // ==================== ç»Ÿè®¡åˆ†æ ====================
        function countNotes(chartData, format) {
            let count = 0;
            
            if (format === 'rpe') {
                if (chartData.judgeLineList) {
                    chartData.judgeLineList.forEach(line => {
                        if (line.notesAbove) count += line.notesAbove.length;
                        if (line.notesBelow) count += line.notesBelow.length;
                    });
                }
            } else if (format === 'phi') {
                if (chartData.noteList) {
                    count = chartData.noteList.length;
                }
            }
            
            return count;
        }

        function getJudgeLineCount(chartData, format) {
            if (format === 'rpe') {
                return chartData.judgeLineList ? chartData.judgeLineList.length : 0;
            } else if (format === 'phi') {
                return chartData.judgeLineList ? chartData.judgeLineList.length : 0;
            }
            return 0;
        }

        function analyzeChartStructure(chartData, format) {
            const info = [];
            
            if (format === 'rpe') {
                info.push('=== RPEæ ¼å¼ç»“æ„ ===');
                
                // BPMä¿¡æ¯
                if (chartData.BPMList && chartData.BPMList.length > 0) {
                    info.push(`âœ“ BPMäº‹ä»¶: ${chartData.BPMList.length} ä¸ª`);
                    info.push(`  åˆå§‹BPM: ${chartData.BPMList[0].bpm || 'æœªçŸ¥'}`);
                }
                
                // åˆ¤å®šçº¿
                const lineCount = chartData.judgeLineList ? chartData.judgeLineList.length : 0;
                info.push(`âœ“ åˆ¤å®šçº¿: ${lineCount} æ¡`);
                
                // éŸ³ç¬¦åˆ†å¸ƒ
                const typeStats = { 1: 0, 2: 0, 3: 0, 4: 0 };
                let fakeCount = 0;
                
                chartData.judgeLineList.forEach((line, idx) => {
                    const notes = [...(line.notesAbove || []), ...(line.notesBelow || [])];
                    notes.forEach(note => {
                        if (note.isFake === 1) fakeCount++;
                        else if (typeStats.hasOwnProperty(note.type)) {
                            typeStats[note.type]++;
                        }
                    });
                });
                
                const total = Object.values(typeStats).reduce((a,b) => a+b, 0);
                info.push(`âœ“ éŸ³ç¬¦ç»Ÿè®¡: å…±${total}ä¸ª (å‡éŸ³ç¬¦${fakeCount}ä¸ª)`);
                info.push(`  Tap: ${typeStats[1]} | Hold: ${typeStats[2]} | Flick: ${typeStats[3]} | Drag: ${typeStats[4]}`);
                
            } else if (format === 'phi') {
                info.push('=== å®˜æ–¹æ ¼å¼ç»“æ„ ===');
                
                info.push(`âœ“ æ ¼å¼ç‰ˆæœ¬: ${chartData.formatVersion}`);
                info.push(`âœ“ åˆ¤å®šçº¿: ${chartData.judgeLineList ? chartData.judgeLineList.length : 0} æ¡`);
                
                const typeStats = { 1: 0, 2: 0, 3: 0, 4: 0 };
                if (chartData.noteList) {
                    chartData.noteList.forEach(note => {
                        if (typeStats.hasOwnProperty(note.type)) {
                            typeStats[note.type]++;
                        }
                    });
                }
                
                const total = Object.values(typeStats).reduce((a,b) => a+b, 0);
                info.push(`âœ“ éŸ³ç¬¦ç»Ÿè®¡: å…±${total}ä¸ª`);
                info.push(`  Tap: ${typeStats[1]} | Drag: ${typeStats[2]} | Hold: ${typeStats[3]} | Flick: ${typeStats[4]}`);
            }
            
            showDebugInfo('ç»“æ„åˆ†æ', info);
        }

        // ==================== è½¬æ¢é€»è¾‘ ====================
        function convertChartData() {
            if (!chartData || !chartFormat) {
                throw new Error('æ²¡æœ‰åŠ è½½è°±é¢æ•°æ®');
            }

            const convertedData = JSON.parse(JSON.stringify(chartData));
            const targetTypeValue = getFormatTypeValue(chartFormat, selectedType);
            const includeHold = includeHoldCheck.checked;
            const holdMinLength = parseInt(holdLengthInput.value) || 200;

            let totalConverted = 0;
            let totalSkipped = 0;
            
            const log = [
                `ç›®æ ‡ç±»å‹: ${selectedType} (${getTypeName(chartFormat, targetTypeValue)})`,
                `åŒ…å«Hold: ${includeHold}`,
                `Holdé•¿åº¦: ${holdMinLength}ms`
            ];

            if (chartFormat === 'rpe') {
                log.push('\n--- RPEæ ¼å¼è½¬æ¢ ---');
                
                chartData.judgeLineList.forEach((line, lineIndex) => {
                    const processLine = (notes, position) => {
                        if (!notes || notes.length === 0) return { c: 0, s: 0 };
                        
                        let converted = 0, skipped = 0;
                        notes.forEach(note => {
                            if (note.isFake === 1) return; // è·³è¿‡å‡éŸ³ç¬¦
                            
                            const originalType = note.type;
                            if (originalType === 2 && !includeHold) { // Holdåœ¨RPEæ˜¯type=2
                                skipped++;
                                return;
                            }
                            
                            if (originalType !== targetTypeValue) {
                                converted++;
                                note.type = targetTypeValue;
                                
                                // Holdç‰¹æ®Šå¤„ç†
                                if (targetTypeValue === 2) { // RPEçš„Hold
                                    // RPEä½¿ç”¨startTimeå’ŒendTimeï¼Œéœ€è¦è®¾ç½®endTime
                                    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œä¿æŒåŸæœ‰ç»“æ„
                                } else if (note.hasOwnProperty('holdTime')) {
                                    delete note.holdTime;
                                }
                            }
                        });
                        
                        return { c: converted, s: skipped };
                    };
                    
                    const above = processLine(convertedData.judgeLineList[lineIndex].notesAbove, 'Above');
                    const below = processLine(convertedData.judgeLineList[lineIndex].notesBelow, 'Below');
                    
                    totalConverted += above.c + below.c;
                    totalSkipped += above.s + below.s;
                    
                    if (above.c + above.s + below.c + below.s > 0) {
                        log.push(`  åˆ¤å®šçº¿${lineIndex + 1}: è½¬æ¢${above.c + below.c}ä¸ª, è·³è¿‡${above.s + below.s}ä¸ª`);
                    }
                });
                
            } else if (chartFormat === 'phi') {
                log.push('\n--- å®˜æ–¹æ ¼å¼è½¬æ¢ ---');
                
                chartData.noteList.forEach((note, index) => {
                    const originalType = note.type;
                    
                    // å®˜æ–¹æ ¼å¼Holdæ˜¯type=3
                    if (originalType === 3 && !includeHold) {
                        totalSkipped++;
                        return;
                    }
                    
                    if (originalType !== targetTypeValue) {
                        totalConverted++;
                        note.type = targetTypeValue;
                        
                        // Holdç‰¹æ®Šå¤„ç†
                        if (targetTypeValue === 3) { // å®˜æ–¹Hold
                            note.holdTime = note.holdTime || holdMinLength;
                        } else if (note.hasOwnProperty('holdTime')) {
                            delete note.holdTime;
                        }
                    }
                });
                
                log.push(`  æ€»è®¡: è½¬æ¢${totalConverted}ä¸ª, è·³è¿‡${totalSkipped}ä¸ª`);
            }

            log.push(`\n=== è½¬æ¢å®Œæˆ ===`);
            log.push(`æ€»è®¡: è½¬æ¢ ${totalConverted} ä¸ª, è·³è¿‡ ${totalSkipped} ä¸ª`);
            
            showDebugInfo('è½¬æ¢æ—¥å¿—', log);
            
            return convertedData;
        }

        // ==================== ä¸‹è½½ ====================
        async function downloadConvertedZip() {
            if (!originalZip || !chartData || !chartFormat) {
                showStatus('è¯·å…ˆä¸Šä¼ è°±é¢', 'error');
                return;
            }

            isProcessing = true;
            downloadBtn.textContent = 'ç”Ÿæˆä¸­...';
            downloadBtn.disabled = true;
            
            try {
                const convertedData = convertChartData();
                
                // åˆ›å»ºæ–°ZIP
                const modifiedZip = new JSZip();
                const files = [];
                
                originalZip.forEach((relativePath) => {
                    if (!originalZip.file(relativePath).dir) {
                        files.push(relativePath);
                    }
                });
                
                // å¹¶è¡Œå¤„ç†æ‰€æœ‰æ–‡ä»¶
                await Promise.all(files.map(async (relativePath) => {
                    if (relativePath === jsonFileName) {
                        // æ›¿æ¢JSON
                        const jsonStr = JSON.stringify(convertedData);
                        modifiedZip.file(relativePath, jsonStr);
                    } else {
                        // å¤åˆ¶å…¶ä»–æ–‡ä»¶
                        const content = await originalZip.file(relativePath).async('uint8array');
                        modifiedZip.file(relativePath, content);
                    }
                }));
                
                // ç”Ÿæˆå¹¶ä¸‹è½½
                const zipBlob = await modifiedZip.generateAsync({
                    type: 'blob',
                    compression: "DEFLATE",
                    compressionOptions: { level: 9 }
                });
                
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${originalFileName}_${selectedType}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('ä¸‹è½½æˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                showStatus('ä¸‹è½½å¤±è´¥: ' + error.message, 'error');
            } finally {
                downloadBtn.textContent = 'ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶';
                downloadBtn.disabled = false;
                isProcessing = false;
            }
        }

        // ==================== UIè¾…åŠ© ====================
        function showDebugInfo(title, content) {
            if (!debugInfo || !debugContent) return;
            
            debugInfo.style.display = 'block';
            debugContent.innerHTML = `<strong style="color: #2c3e50;">${title}</strong><br>`;
            
            if (Array.isArray(content)) {
                content.forEach(line => {
                    const color = line.startsWith('âŒ') ? '#e74c3c' : 
                                 line.startsWith('âœ“') ? '#27ae60' : 
                                 line.startsWith('âš ') ? '#f39c12' : 
                                 line.startsWith('---') || line.startsWith('===') ? '#9b59b6' : '#34495e';
                    debugContent.innerHTML += `<span style="color: ${color};">${line}</span><br>`;
                });
            } else if (typeof content === 'object') {
                for (const [key, value] of Object.entries(content)) {
                    debugContent.innerHTML += `<span style="color: #34495e;">${key}:</span> <span style="color: #7f8c8d;">${value}</span><br>`;
                }
            } else {
                debugContent.innerHTML += content;
            }
            
            // è‡ªåŠ¨æ»šåŠ¨
            debugContent.parentElement.scrollTop = debugContent.parentElement.scrollHeight;
        }

        function showStatus(message, type = 'success') {
            if (!status) return;
            
            status.textContent = message;
            status.className = `status show ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.classList.remove('show');
                setTimeout(() => { status.style.display = 'none'; }, 300);
            }, 5000);
        }

        // ==================== å¯åŠ¨ ====================
        document.addEventListener('DOMContentLoaded', () => {
            init();
        });

        // å…¨å±€é”™è¯¯æ•è·
        window.addEventListener('error', (event) => {
            console.error('å…¨å±€é”™è¯¯:', event.error);
            showStatus('å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°', 'error');
        });
    </script>
</body>
</html>