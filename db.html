<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhigrosæŒ‰é”®è½¬æ¢å™¨</title>
    <link rel="stylesheet" href="common.css">
</head>
<body>
    <div class="container">
    <header>
            <h1>PhigrosæŒ‰é”®è½¬æ¢å™¨</h1>
        </header>
        
        <div class="main-content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <p>ä¸Šä¼ Phigrosè°±é¢ZIPæ–‡ä»¶</p>
                <input type="file" id="fileInput" accept=".zip">
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>å¤„ç†ä¸­...</p>
            </div>
            
            <div class="controls-section" id="controlsSection">
                <div class="file-info" id="fileInfo">
                    <div class="info-item">
                        <span>æ–‡ä»¶:</span>
                        <span id="fileName">-</span>
                    </div>
                    <div class="info-item">
                        <span>æŒ‰é”®æ•°:</span>
                        <span id="noteCount">-</span>
                    </div>
                    <div class="info-item">
                        <span>æ ¼å¼:</span>
                        <span id="chartFormat">-</span>
                    </div>
                    <div class="info-item">
                        <span>formatVersion:</span>
                        <span id="formatVersion">-</span>
                    </div>
                    <div class="info-item">
                        <span>åˆ¤å®šçº¿æ•°:</span>
                        <span id="judgeLineCount">-</span>
                    </div>
                    <div class="info-item">
                        <span>BPMæ•°é‡:</span>
                        <span id="bpmCount">-</span>
                    </div>
                </div>
                
                <div class="conversion-controls">
                    <div class="conversion-options">
                        <button class="conversion-btn" data-type="tap">Tap</button>
                        <button class="conversion-btn" data-type="drag">Drag</button>
                        <button class="conversion-btn" data-type="hold">Hold</button>
                        <button class="conversion-btn" data-type="flick">Flick</button>
                    </div>
                    
                    <div class="hold-controls" id="holdControls">
                        <div class="hold-option">
                            <input type="checkbox" id="includeHold" checked>
                            <label for="includeHold">åŒ…å«HoldæŒ‰é”®</label>
                        </div>
                        <div class="hold-length" id="holdLengthControl">
                            <label>æœ€å°é•¿åº¦:</label>
                            <input type="number" id="holdLength" value="200" min="50" max="1000">
                            <span>ms</span>
                        </div>
                    </div>
                </div>
                
                <button class="download-btn" id="downloadBtn" disabled>
                    ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶
                </button>
                
                <div class="status" id="status"></div>
                
                <!-- è°ƒè¯•ä¿¡æ¯åŒºåŸŸ -->
                <div class="debug-info" id="debugInfo" style="display: none; margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto;">
                    <h4 style="margin-bottom: 10px; margin-top: 0;">è°ƒè¯•ä¿¡æ¯</h4>
                    <div id="debugContent"></div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>æœ¬å·¥å…·å®Œå…¨åœ¨æµè§ˆå™¨ä¸­è¿è¡Œï¼Œä¸ä¼šä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨</p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let originalZip = null
        let jsonFileName = null
        let chartData = null
        let chartFormat = null // rpe / phi / unknown
        let selectedType = 'tap'
        let originalFileName = ''
        let bpmProcessor = null // BPMå¤„ç†å™¨å®ä¾‹
        
        // ç±»å‹æ˜ å°„è¡¨ï¼ˆä¸¥æ ¼æŒ‰ç…§æ–‡æ¡£ï¼‰
        const TYPE_MAPPING = {
            // ç›®æ ‡ç±»å‹ -> æ ¼å¼å¯¹åº”çš„æ•°å€¼
            rpe: {
                tap: 1,
                hold: 2,
                flick: 3,
                drag: 4
            },
            phi: {
                tap: 1,
                drag: 2,
                hold: 3,
                flick: 4
            },
            // åå‘æ˜ å°„ï¼šæ•°å€¼ -> ç±»å‹åç§°
            valueToName: {
                1: 'Tap',
                2: 'Hold/Raw', // å–å†³äºæ ¼å¼
                3: 'Flick/Hold', // å–å†³äºæ ¼å¼
                4: 'Drag/Flick'  // å–å†³äºæ ¼å¼
            }
        }
        
        // DOMå…ƒç´ 
        const uploadArea = document.getElementById('uploadArea')
        const fileInput = document.getElementById('fileInput')
        const loading = document.getElementById('loading')
        const controlsSection = document.getElementById('controlsSection')
        const downloadBtn = document.getElementById('downloadBtn')
        const status = document.getElementById('status')
        const holdControls = document.getElementById('holdControls')
        const holdLengthControl = document.getElementById('holdLengthControl')
        const includeHoldCheck = document.getElementById('includeHold')
        const holdLengthInput = document.getElementById('holdLength')
        
        const fileNameSpan = document.getElementById('fileName')
        const noteCountSpan = document.getElementById('noteCount')
        const chartFormatSpan = document.getElementById('chartFormat')
        const formatVersionSpan = document.getElementById('formatVersion')
        const judgeLineCountSpan = document.getElementById('judgeLineCount')
        const bpmCountSpan = document.getElementById('bpmCount')
        const debugInfo = document.getElementById('debugInfo')
        const debugContent = document.getElementById('debugContent')
        
        // BPMå¤„ç†å™¨ç±»ï¼ˆå®ç°æ–‡æ¡£ä¸­çš„æ—¶é—´è½¬æ¢é€»è¾‘ï¼‰
        class BPMProcessor {
            constructor(format, bpmList, judgeLineList) {
                this.format = format
                this.bpmList = this.parseBPMList(bpmList)
                this.judgeLineList = judgeLineList || []
                this.debugLog = []
            }
            
            // è§£æBPMListï¼ˆå…¼å®¹RPEæ ¼å¼ï¼‰
            parseBPMList(bpmList) {
                if (!bpmList || !Array.isArray(bpmList)) {
                    this.debugLog.push('BPMListä¸å­˜åœ¨æˆ–æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤BPM')
                    return [{
                        startTime: this.parseBeat([0, 0, 1]), // 0æ‹
                        bpm: 120.0
                    }]
                }
                
                const parsed = []
                bpmList.forEach((item, index) => {
                    try {
                        let startTime = item.startTime
                        // è§£æRPEçš„beatæ ¼å¼ï¼ˆint[3]ï¼‰
                        if (Array.isArray(startTime) && startTime.length === 3) {
                            startTime = this.parseBeat(startTime)
                        } else if (typeof startTime === 'object' && startTime.value !== undefined) {
                            startTime = startTime.value // å…¼å®¹å¯èƒ½çš„å¯¹è±¡æ ¼å¼
                        } else if (typeof startTime !== 'number') {
                            startTime = 0
                        }
                        
                        parsed.push({
                            startTime: startTime,
                            bpm: parseFloat(item.bpm) || 120.0
                        })
                    } catch (e) {
                        this.debugLog.push(`è§£æBPMäº‹ä»¶${index}å¤±è´¥: ${e.message}`)
                    }
                })
                
                // æ’åºå¹¶å»é‡
                parsed.sort((a, b) => a.startTime - b.startTime)
                const uniqueBPMs = []
                parsed.forEach(item => {
                    if (uniqueBPMs.length === 0 || item.startTime !== uniqueBPMs[uniqueBPMs.length - 1].startTime) {
                        uniqueBPMs.push(item)
                    }
                })
                
                this.debugLog.push(`è§£æå®Œæˆ${uniqueBPMs.length}ä¸ªBPMäº‹ä»¶`)
                return uniqueBPMs
            }
            
            // è§£æRPEçš„beatæ ¼å¼ [0]:[1]/[2] -> æ•°å€¼
            parseBeat(beatArray) {
                if (!Array.isArray(beatArray) || beatArray.length !== 3) {
                    throw new Error(`æ— æ•ˆçš„beatæ ¼å¼: ${JSON.stringify(beatArray)}`)
                }
                const [bar, beat, denom] = beatArray
                return bar + (beat / denom)
            }
            
            // å°†beatè½¬æ¢ä¸ºç§’ï¼ˆå®ç°æ–‡æ¡£ä¸­çš„beat2secï¼‰
            beat2sec(t, judgeLineIndex = 0) {
                if (this.format !== 'rpe') {
                    return t // éRPEæ ¼å¼ç›´æ¥è¿”å›
                }
                
                let sec = 0.0
                const judgeLine = this.judgeLineList[judgeLineIndex] || {}
                const bpmfactor = parseFloat(judgeLine.bpmfactor) || 1.0
                
                for (let i = 0; i < this.bpmList.length; i++) {
                    const e = this.bpmList[i]
                    const bpmv = e.bpm / bpmfactor
                    
                    if (i !== this.bpmList.length - 1) {
                        const et_beat = this.bpmList[i + 1].startTime - e.startTime
                        
                        if (t >= et_beat) {
                            sec += et_beat * (60 / bpmv)
                            t -= et_beat
                        } else {
                            sec += t * (60 / bpmv)
                            break
                        }
                    } else {
                        sec += t * (60 / bpmv)
                        break
                    }
                }
                
                return sec
            }
            
            // å°†ç§’è½¬æ¢ä¸ºbeatï¼ˆå®ç°æ–‡æ¡£ä¸­çš„sec2beatï¼‰
            sec2beat(t, judgeLineIndex = 0) {
                if (this.format !== 'rpe') {
                    return t // éRPEæ ¼å¼ç›´æ¥è¿”å›
                }
                
                let beat = 0.0
                const judgeLine = this.judgeLineList[judgeLineIndex] || {}
                const bpmfactor = parseFloat(judgeLine.bpmfactor) || 1.0
                
                for (let i = 0; i < this.bpmList.length; i++) {
                    const e = this.bpmList[i]
                    const bpmv = e.bpm / bpmfactor
                    
                    if (i !== this.bpmList.length - 1) {
                        const et_beat = this.bpmList[i + 1].startTime - e.startTime
                        const et_sec = et_beat * (60 / bpmv)
                        
                        if (t >= et_sec) {
                            beat += et_beat
                            t -= et_sec
                        } else {
                            beat += t / (60 / bpmv)
                            break
                        }
                    } else {
                        beat += t / (60 / bpmv)
                        break
                    }
                }
                
                return beat
            }
            
            // è§£æéŸ³ç¬¦çš„æ—¶é—´ï¼ˆå…¼å®¹ä¸¤ç§æ ¼å¼ï¼‰
            parseNoteTime(note, judgeLineIndex = 0) {
                if (this.format === 'rpe') {
                    // RPEæ ¼å¼ï¼šstartTimeå’ŒendTimeæ˜¯beat
                    let startTime = note.startTime
                    let endTime = note.endTime
                    
                    // è§£æbeatæ ¼å¼
                    if (Array.isArray(startTime)) startTime = this.parseBeat(startTime)
                    if (Array.isArray(endTime)) endTime = this.parseBeat(endTime)
                    
                    // è½¬æ¢ä¸ºç§’
                    const startSec = this.beat2sec(startTime, judgeLineIndex)
                    const endSec = this.beat2sec(endTime, judgeLineIndex)
                    
                    return {
                        startSec,
                        endSec,
                        durationSec: endSec - startSec,
                        startTimeBeat: startTime,
                        endTimeBeat: endTime
                    }
                } else if (this.format === 'phi') {
                    // å®˜æ–¹æ ¼å¼ï¼štimeå•ä½æ˜¯1.875/bpmï¼ŒholdTimeåŒå•ä½
                    const noteTime = parseFloat(note.time) || 0
                    const holdTime = parseFloat(note.holdTime) || 0
                    
                    // è½¬æ¢ä¸ºç§’ï¼ˆå‡è®¾BPM=120ä½œä¸ºåŸºå‡†ï¼Œå®é™…ä½¿ç”¨æ—¶æ ¹æ®BPMè°ƒæ•´ï¼‰
                    // å®˜æ–¹æ ¼å¼çš„æ—¶é—´å•ä½æ˜¯ç›¸å¯¹çš„ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
                    const bpm = this.bpmList[0]?.bpm || 120
                    const secPerUnit = 1.875 / bpm
                    const startSec = noteTime * secPerUnit
                    const endSec = startSec + (holdTime * secPerUnit)
                    
                    return {
                        startSec,
                        endSec,
                        durationSec: endSec - startSec,
                        timeUnit: noteTime,
                        holdTimeUnit: holdTime
                    }
                }
                
                return { startSec: 0, endSec: 0, durationSec: 0 }
            }
            
            getDebugLog() {
                return this.debugLog
            }
        }
        
        function init() {
            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
            uploadArea.addEventListener('click', () => fileInput.click())
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault()
                uploadArea.style.borderColor = '#3498db'
            })
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '#bdc3c7'
            })
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault()
                uploadArea.style.borderColor = '#bdc3c7'
                if (e.dataTransfer.files.length) {
                    handleFileUpload(e.dataTransfer.files[0])
                }
            })
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    handleFileUpload(e.target.files[0])
                }
            })
            
            // è½¬æ¢ç±»å‹é€‰æ‹©
            document.querySelectorAll('.conversion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.conversion-btn').forEach(b => b.classList.remove('selected'))
                    this.classList.add('selected')
                    selectedType = this.dataset.type
                    
                    // æ˜¾ç¤º/éšè—Holdç›¸å…³æ§åˆ¶
                    if (selectedType === 'hold') {
                        holdLengthControl.style.display = 'flex'
                        includeHoldCheck.style.display = 'none'
                    } else {
                        holdLengthControl.style.display = 'none'
                        includeHoldCheck.style.display = 'flex'
                    }
                })
            })
            
            document.querySelector('.conversion-btn[data-type="tap"]').click()
            downloadBtn.addEventListener('click', downloadConvertedZip)
        }
        
        /**
         * ä¸¥æ ¼çš„æ ¼å¼åˆ¤æ–­é€»è¾‘ï¼ˆåŸºäºæ–‡æ¡£ï¼‰
         */
        function determineChartFormat(data) {
            const log = []
            
            // 1. å®˜æ–¹æ ¼å¼åˆ¤æ–­ï¼ˆphiï¼‰
            if (data.formatVersion) {
                const versionStr = data.formatVersion.toString().toLowerCase()
                log.push(`formatVersion: ${data.formatVersion}`)
                
                if (versionStr.startsWith('phi-')) {
                    log.push('âœ“ formatVersionä»¥"phi-"å¼€å¤´ â†’ å®˜æ–¹æ ¼å¼')
                    showDebugInfo('æ ¼å¼åˆ¤æ–­', log)
                    return 'phi'
                }
            }
            
            // 2. RPEæ ¼å¼åˆ¤æ–­
            if (data.BPMList && Array.isArray(data.BPMList)) {
                log.push(`âœ“ æ‰¾åˆ°BPMListï¼ˆRPEæ ¸å¿ƒå­—æ®µï¼‰ï¼Œé•¿åº¦: ${data.BPMList.length}`)
                
                if (data.judgeLineList && Array.isArray(data.judgeLineList)) {
                    const firstLine = data.judgeLineList[0]
                    if (firstLine && (firstLine.notesAbove || firstLine.notesBelow)) {
                        log.push('âœ“ judgeLineListåŒ…å«notesAbove/notesBelow â†’ RPEæ ¼å¼')
                        showDebugInfo('æ ¼å¼åˆ¤æ–­', log)
                        return 'rpe'
                    } else {
                        log.push('âœ— judgeLineListä¸åŒ…å«notesAbove/notesBelow')
                    }
                } else {
                    log.push('âœ— æœªæ‰¾åˆ°judgeLineList')
                }
            } else {
                log.push('âœ— æœªæ‰¾åˆ°BPMListï¼ˆRPEæ ¸å¿ƒå­—æ®µï¼‰')
            }
            
            // 3. è¡¥å……åˆ¤æ–­
            if (data.noteList && Array.isArray(data.noteList)) {
                log.push(`âœ“ æ‰¾åˆ°noteListï¼ˆå®˜æ–¹æ ¼å¼æ ¸å¿ƒå­—æ®µï¼‰ï¼Œé•¿åº¦: ${data.noteList.length}`)
                log.push('â†’ åˆ¤å®šä¸ºå®˜æ–¹æ ¼å¼(phi)')
                showDebugInfo('æ ¼å¼åˆ¤æ–­', log)
                return 'phi'
            }
            
            log.push('â†’ æ— æ³•æ˜ç¡®åˆ¤å®šæ ¼å¼')
            showDebugInfo('æ ¼å¼åˆ¤æ–­', log)
            return 'unknown'
        }
        
        async function handleFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.zip')) {
                showStatus('è¯·ä¸Šä¼ ZIPæ–‡ä»¶', 'error')
                return
            }
            
            loading.classList.add('show')
            debugContent.innerHTML = ''
            
            try {
                // è¯»å–ZIPæ–‡ä»¶
                const arrayBuffer = await file.arrayBuffer()
                originalZip = await JSZip.loadAsync(arrayBuffer)
                originalFileName = file.name.replace(/\.zip$/i, '')
                
                // æŸ¥æ‰¾è°±é¢JSONæ–‡ä»¶
                const jsonFiles = []
                originalZip.forEach((relativePath, fileEntry) => {
                    if (!fileEntry.dir && relativePath.toLowerCase().endsWith('.json')) {
                        jsonFiles.push(relativePath)
                    }
                })
                
                if (jsonFiles.length === 0) {
                    throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°JSONæ–‡ä»¶')
                }
                
                // ä¼˜å…ˆé€‰æ‹©å¸¸è§çš„è°±é¢æ–‡ä»¶å
                const chartFileNames = ['chart.json', 'level.json', 'data.json', 'song.json']
                let possibleChartFile = null
                for (const name of chartFileNames) {
                    possibleChartFile = jsonFiles.find(path => path.toLowerCase().includes(name))
                    if (possibleChartFile) break
                }
                jsonFileName = possibleChartFile || jsonFiles[0]
                
                // è¯»å–JSONæ–‡ä»¶
                const jsonFile = originalZip.file(jsonFileName)
                if (!jsonFile) {
                    throw new Error(`æ— æ³•è¯»å–JSONæ–‡ä»¶: ${jsonFileName}`)
                }
                
                const jsonText = await jsonFile.async('text')
                chartData = JSON.parse(jsonText)
                
                // åˆ¤å®šæ ¼å¼
                chartFormat = determineChartFormat(chartData)
                if (chartFormat === 'unknown') {
                    throw new Error('æ— æ³•è¯†åˆ«çš„è°±é¢æ ¼å¼ï¼Œè¯·ä½¿ç”¨æ ‡å‡†çš„RPEæˆ–å®˜æ–¹phiæ ¼å¼')
                }
                
                // åˆå§‹åŒ–BPMå¤„ç†å™¨
                bpmProcessor = new BPMProcessor(
                    chartFormat,
                    chartData.BPMList,
                    chartData.judgeLineList
                )
                
                // è§£æè°±é¢ä¿¡æ¯
                const noteCount = countNotes(chartData, chartFormat)
                const judgeLineCount = getJudgeLineCount(chartData, chartFormat)
                const bpmCount = bpmProcessor.bpmList.length
                
                // æ›´æ–°UIæ˜¾ç¤º
                fileNameSpan.textContent = file.name
                noteCountSpan.textContent = noteCount
                chartFormatSpan.textContent = chartFormat === 'rpe' ? 'RPE' : 'å®˜æ–¹æ ¼å¼(phi)'
                formatVersionSpan.textContent = chartData.formatVersion || 'æœªçŸ¥'
                judgeLineCountSpan.textContent = judgeLineCount
                bpmCountSpan.textContent = bpmCount
                
                // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                showDebugInfo('æ–‡ä»¶åŠ è½½æˆåŠŸ', [
                    `æ–‡ä»¶å: ${file.name}`,
                    `JSONæ–‡ä»¶è·¯å¾„: ${jsonFileName}`,
                    `è°±é¢æ ¼å¼: ${chartFormat === 'rpe' ? 'RPE' : 'å®˜æ–¹æ ¼å¼(phi)'}`,
                    `formatVersion: ${chartData.formatVersion || 'æ— '}`,
                    `åˆ¤å®šçº¿æ•°é‡: ${judgeLineCount}`,
                    `BPMäº‹ä»¶æ•°é‡: ${bpmCount}`,
                    `æ€»æŒ‰é”®æ•°: ${noteCount}`,
                    `æ•°æ®å¤§å°: ${jsonText.length} å­—ç¬¦`
                ])
                
                // æ˜¾ç¤ºBPMä¿¡æ¯
                showDebugInfo('BPMä¿¡æ¯', [
                    'BPMäº‹ä»¶åˆ—è¡¨:',
                    ...bpmProcessor.bpmList.map((item, i) => 
                        `  [${i}] èµ·å§‹æ‹: ${item.startTime.toFixed(2)}, BPM: ${item.bpm.toFixed(1)}`
                    ),
                    ...bpmProcessor.getDebugLog()
                ])
                
                // åˆ†æè°±é¢ç»“æ„
                analyzeChartStructure(chartData, chartFormat)
                
                // æ˜¾ç¤ºæ§åˆ¶åŒºåŸŸ
                controlsSection.classList.add('show')
                debugInfo.style.display = 'block'
                downloadBtn.disabled = false
                
                showStatus('æˆåŠŸåŠ è½½è°±é¢', 'success')
                
            } catch (error) {
                showStatus(`å¤„ç†å¤±è´¥: ${error.message}`, 'error')
                showDebugInfo('åŠ è½½é”™è¯¯', [
                    `é”™è¯¯ä¿¡æ¯: ${error.message}`,
                    `JSONæ–‡ä»¶: ${jsonFileName || 'æœªæ‰¾åˆ°'}`,
                    `å¯ç”¨JSONæ–‡ä»¶: ${jsonFiles.join(', ')}`,
                    `é”™è¯¯å †æ ˆ: ${error.stack ? error.stack.substring(0, 500) + '...' : 'æ— '}`
                ])
            } finally {
                loading.classList.remove('show')
            }
        }
        
        /**
         * è®¡æ•°éŸ³ç¬¦ï¼ˆå…¼å®¹ä¸¤ç§æ ¼å¼ï¼‰
         */
        function countNotes(chartData, format) {
            if (format === 'rpe') {
                let count = 0
                if (chartData.judgeLineList && Array.isArray(chartData.judgeLineList)) {
                    chartData.judgeLineList.forEach(line => {
                        if (line.notesAbove && Array.isArray(line.notesAbove)) {
                            // è¿‡æ»¤å‡éŸ³ç¬¦ï¼ˆisFake=1ï¼‰
                            count += line.notesAbove.filter(note => note.isFake !== 1).length
                        }
                        if (line.notesBelow && Array.isArray(line.notesBelow)) {
                            count += line.notesBelow.filter(note => note.isFake !== 1).length
                        }
                    })
                }
                return count
            } else if (format === 'phi') {
                return chartData.noteList && Array.isArray(chartData.noteList) 
                    ? chartData.noteList.length 
                    : 0
            }
            return 0
        }
        
        /**
         * è·å–åˆ¤å®šçº¿æ•°é‡
         */
        function getJudgeLineCount(chartData, format) {
            if (chartData.judgeLineList && Array.isArray(chartData.judgeLineList)) {
                return chartData.judgeLineList.length
            }
            if (format === 'phi' && chartData.noteList && Array.isArray(chartData.noteList)) {
                return 1 // å®˜æ–¹æ ¼å¼é»˜è®¤1æ¡åˆ¤å®šçº¿
            }
            return 0
        }
        
        /**
         * åˆ†æè°±é¢ç»“æ„
         */
        function analyzeChartStructure(chartData, format) {
            const structureInfo = []
            
            if (format === 'rpe') {
                structureInfo.push('=== RPEæ ¼å¼è°±é¢ç»“æ„åˆ†æï¼ˆæŒ‰æ–‡æ¡£æ ‡å‡†ï¼‰ ===')
                structureInfo.push('æ ¸å¿ƒç‰¹å¾ï¼šBPMList + judgeLineList(notesAbove/notesBelow)')
                structureInfo.push('éŸ³ç¬¦æ—¶é—´å•ä½ï¼šbeat ([0]:[1]/[2])')
                structureInfo.push('éŸ³ç¬¦ç±»å‹æ˜ å°„ï¼š1=Tap, 2=Hold, 3=Flick, 4=Drag')
                structureInfo.push('')
                
                // æ£€æŸ¥æ ¸å¿ƒå­—æ®µ
                structureInfo.push('æ ¸å¿ƒå­—æ®µæ£€æŸ¥:')
                structureInfo.push(`  BPMList: ${chartData.BPMList ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'} (${chartData.BPMList?.length || 0}ä¸ªäº‹ä»¶)`)
                structureInfo.push(`  judgeLineList: ${chartData.judgeLineList ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'} (${chartData.judgeLineList?.length || 0}æ¡çº¿)`)
                structureInfo.push('')
                
                // åˆ†ææ¯æ¡åˆ¤å®šçº¿
                if (chartData.judgeLineList && Array.isArray(chartData.judgeLineList)) {
                    chartData.judgeLineList.forEach((line, lineIndex) => {
                        structureInfo.push(`åˆ¤å®šçº¿ ${lineIndex + 1}:`)
                        structureInfo.push(`  ID: ${line.id || 'æ— '}`)
                        structureInfo.push(`  bpmfactor: ${line.bpmfactor || 1.0}`)
                        structureInfo.push(`  å¯è§æ€§: ${line.visible !== undefined ? line.visible : 'é»˜è®¤å¯è§'}`)
                        
                        // åˆ†ænotesAbove
                        if (line.notesAbove && Array.isArray(line.notesAbove)) {
                            const noteTypes = countNoteTypes(line.notesAbove, format)
                            structureInfo.push(`  notesAbove: ${line.notesAbove.length} ä¸ªéŸ³ç¬¦`)
                            for (const [type, count] of Object.entries(noteTypes)) {
                                structureInfo.push(`    - ${getTypeName(type, format)}: ${count} ä¸ª`)
                            }
                            
                            // åˆ†æå‰2ä¸ªéŸ³ç¬¦çš„è¯¦ç»†ä¿¡æ¯
                            const sampleNotes = line.notesAbove.slice(0, 2)
                            sampleNotes.forEach((note, i) => {
                                const timeInfo = bpmProcessor.parseNoteTime(note, lineIndex)
                                structureInfo.push(`    éŸ³ç¬¦ ${i+1} è¯¦æƒ…:`)
                                structureInfo.push(`      ç±»å‹: ${getTypeName(note.type, format)} (${note.type})`)
                                structureInfo.push(`      æ—¶é—´: ${JSON.stringify(note.startTime)} â†’ ${JSON.stringify(note.endTime)}`)
                                structureInfo.push(`      æ—¶é•¿: ${timeInfo.durationSec.toFixed(3)}s`)
                                structureInfo.push(`      ä½ç½®X: ${note.positionX || 0}`)
                                structureInfo.push(`      é¢œè‰²: ${note.tint || note.color || '[255,255,255]'}`)
                                structureInfo.push(`      å‡éŸ³ç¬¦: ${note.isFake === 1 ? 'æ˜¯' : 'å¦'}`)
                            })
                        } else {
                            structureInfo.push(`  notesAbove: æ— `)
                        }
                        
                        // åˆ†ænotesBelow
                        if (line.notesBelow && Array.isArray(line.notesBelow)) {
                            const noteTypes = countNoteTypes(line.notesBelow, format)
                            structureInfo.push(`  notesBelow: ${line.notesBelow.length} ä¸ªéŸ³ç¬¦`)
                            for (const [type, count] of Object.entries(noteTypes)) {
                                structureInfo.push(`    - ${getTypeName(type, format)}: ${count} ä¸ª`)
                            }
                        } else {
                            structureInfo.push(`  notesBelow: æ— `)
                        }
                        
                        structureInfo.push('')
                    })
                }
                
            } else if (format === 'phi') {
                structureInfo.push('=== å®˜æ–¹æ ¼å¼(phi)è°±é¢ç»“æ„åˆ†æï¼ˆæŒ‰æ–‡æ¡£æ ‡å‡†ï¼‰ ===')
                structureInfo.push('æ ¸å¿ƒç‰¹å¾ï¼šformatVersion + noteList')
                structureInfo.push('éŸ³ç¬¦æ—¶é—´å•ä½ï¼š1.875/bpm')
                structureInfo.push('éŸ³ç¬¦ç±»å‹æ˜ å°„ï¼š1=Tap, 2=Drag, 3=Hold, 4=Flick')
                structureInfo.push('')
                
                // æ£€æŸ¥æ ¸å¿ƒå­—æ®µ
                structureInfo.push('æ ¸å¿ƒå­—æ®µæ£€æŸ¥:')
                structureInfo.push(`  formatVersion: ${chartData.formatVersion || 'æ— '}`)
                structureInfo.push(`  noteList: ${chartData.noteList ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'} (${chartData.noteList?.length || 0}ä¸ªéŸ³ç¬¦)`)
                structureInfo.push(`  judgeLineList: ${chartData.judgeLineList ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'} (${chartData.judgeLineList?.length || 0}æ¡çº¿)`)
                structureInfo.push('')
                
                // åˆ†æéŸ³ç¬¦åˆ—è¡¨
                if (chartData.noteList && Array.isArray(chartData.noteList)) {
                    const noteTypes = countNoteTypes(chartData.noteList, format)
                    structureInfo.push('éŸ³ç¬¦ç±»å‹åˆ†å¸ƒ:')
                    for (const [type, count] of Object.entries(noteTypes)) {
                        structureInfo.push(`  - ${getTypeName(type, format)}: ${count} ä¸ª (${(count/chartData.noteList.length*100).toFixed(1)}%)`)
                    }
                    structureInfo.push('')
                    
                    // åˆ†æå‰2ä¸ªéŸ³ç¬¦çš„è¯¦ç»†ä¿¡æ¯
                    const sampleNotes = chartData.noteList.slice(0, 2)
                    sampleNotes.forEach((note, i) => {
                        const timeInfo = bpmProcessor.parseNoteTime(note)
                        structureInfo.push(`éŸ³ç¬¦ ${i+1} è¯¦æƒ…:`)
                        structureInfo.push(`  ç±»å‹: ${getTypeName(note.type, format)} (${note.type})`)
                        structureInfo.push(`  æ—¶é—´: ${note.time.toFixed(3)} (${timeInfo.startSec.toFixed(3)}s)`)
                        structureInfo.push(`  æŒç»­æ—¶é—´: ${note.holdTime.toFixed(3)} (${timeInfo.durationSec.toFixed(3)}s)`)
                        structureInfo.push(`  ä½ç½®X: ${note.positionX || 0}`)
                        structureInfo.push(`  é€Ÿåº¦: ${note.speed || 1.0}`)
                        structureInfo.push(`  åˆ¤å®šçº¿: ${note.judgeLine || 0}`)
                        structureInfo.push('')
                    })
                }
            }
            
            showDebugInfo('è°±é¢ç»“æ„åˆ†æ', structureInfo)
        }
        
        /**
         * ç»Ÿè®¡éŸ³ç¬¦ç±»å‹åˆ†å¸ƒ
         */
        function countNoteTypes(notesArray, format) {
            const count = {}
            notesArray.forEach(note => {
                const type = note.type || 0
                count[type] = (count[type] || 0) + 1
            })
            return count
        }
        
        /**
         * è·å–éŸ³ç¬¦ç±»å‹åç§°ï¼ˆå…¼å®¹ä¸¤ç§æ ¼å¼ï¼‰
         */
        function getTypeName(type, format) {
            type = parseInt(type) || 0
            if (format === 'rpe') {
                switch(type) {
                    case 1: return 'Tap'
                    case 2: return 'Hold'
                    case 3: return 'Flick'
                    case 4: return 'Drag'
                    default: return `æœªçŸ¥(${type})`
                }
            } else if (format === 'phi') {
                switch(type) {
                    case 1: return 'Tap'
                    case 2: return 'Drag'
                    case 3: return 'Hold'
                    case 4: return 'Flick'
                    default: return `æœªçŸ¥(${type})`
                }
            }
            return TYPE_MAPPING.valueToName[type] || `æœªçŸ¥(${type})`
        }
        
        /**
         * è½¬æ¢è°±é¢æ•°æ®ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰
         */
        function convertChartData() {
            if (!chartData || !chartFormat || !bpmProcessor) return null
            
            const convertedData = JSON.parse(JSON.stringify(chartData))
            const targetType = TYPE_MAPPING[chartFormat][selectedType]
            const includeHold = includeHoldCheck.checked
            const holdMinLengthMs = parseInt(holdLengthInput.value) || 200
            const holdMinLengthSec = holdMinLengthMs / 1000
            
            let totalConverted = 0
            let totalSkipped = 0
            const conversionLog = []
            
            conversionLog.push(`=== å¼€å§‹è½¬æ¢ ===`)
            conversionLog.push(`ç›®æ ‡ç±»å‹: ${selectedType} (${targetType})`)
            conversionLog.push(`åŒ…å«Hold: ${includeHold}`)
            conversionLog.push(`Holdæœ€å°é•¿åº¦: ${holdMinLengthMs}ms (${holdMinLengthSec}s)`)
            conversionLog.push(`è°±é¢æ ¼å¼: ${chartFormat}`)
            conversionLog.push('')
            
            if (chartFormat === 'rpe') {
                // RPEæ ¼å¼è½¬æ¢ï¼šå¤„ç†æ¯æ¡åˆ¤å®šçº¿çš„notesAbove/notesBelow
                if (!convertedData.judgeLineList || !Array.isArray(convertedData.judgeLineList)) {
                    conversionLog.push('âŒ é”™è¯¯ï¼šæœªæ‰¾åˆ°judgeLineList')
                    showDebugInfo('è½¬æ¢æ—¥å¿—', conversionLog)
                    return convertedData
                }
                
                convertedData.judgeLineList.forEach((judgeLine, lineIndex) => {
                    conversionLog.push(`å¤„ç†åˆ¤å®šçº¿ ${lineIndex + 1}:`)
                    
                    // å¤„ç†notesAbove
                    if (judgeLine.notesAbove && Array.isArray(judgeLine.notesAbove)) {
                        conversionLog.push(`  å¤„ç†notesAbove (${judgeLine.notesAbove.length}ä¸ªéŸ³ç¬¦)`)
                        const { converted, skipped } = processRPENotes(
                            judgeLine.notesAbove, 
                            targetType, 
                            includeHold, 
                            holdMinLengthSec, 
                            lineIndex,
                            conversionLog
                        )
                        totalConverted += converted
                        totalSkipped += skipped
                    } else {
                        conversionLog.push(`  æ— notesAbove`)
                    }
                    
                    // å¤„ç†notesBelow
                    if (judgeLine.notesBelow && Array.isArray(judgeLine.notesBelow)) {
                        conversionLog.push(`  å¤„ç†notesBelow (${judgeLine.notesBelow.length}ä¸ªéŸ³ç¬¦)`)
                        const { converted, skipped } = processRPENotes(
                            judgeLine.notesBelow, 
                            targetType, 
                            includeHold, 
                            holdMinLengthSec, 
                            lineIndex,
                            conversionLog
                        )
                        totalConverted += converted
                        totalSkipped += skipped
                    } else {
                        conversionLog.push(`  æ— notesBelow`)
                    }
                    
                    conversionLog.push('')
                })
                
            } else if (chartFormat === 'phi') {
                // å®˜æ–¹æ ¼å¼è½¬æ¢ï¼šå¤„ç†noteList
                if (!convertedData.noteList || !Array.isArray(convertedData.noteList)) {
                    conversionLog.push('âŒ é”™è¯¯ï¼šæœªæ‰¾åˆ°noteList')
                    showDebugInfo('è½¬æ¢æ—¥å¿—', conversionLog)
                    return convertedData
                }
                
                conversionLog.push(`å¤„ç†noteList (${convertedData.noteList.length}ä¸ªéŸ³ç¬¦)`)
                const { converted, skipped } = processPhiNotes(
                    convertedData.noteList,
                    targetType,
                    includeHold,
                    holdMinLengthSec,
                    conversionLog
                )
                totalConverted += converted
                totalSkipped += skipped
            }
            
            // è½¬æ¢ç»Ÿè®¡
            conversionLog.push(`=== è½¬æ¢å®Œæˆ ===`)
            conversionLog.push(`æ€»è®¡ï¼šè½¬æ¢${totalConverted}ä¸ªéŸ³ç¬¦ï¼Œè·³è¿‡${totalSkipped}ä¸ªéŸ³ç¬¦`)
            
            // æ›´æ–°æ€»éŸ³ç¬¦æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (convertedData.numOfNotes !== undefined) {
                convertedData.numOfNotes = totalConverted + totalSkipped
                conversionLog.push(`æ›´æ–°numOfNotes: ${convertedData.numOfNotes}`)
            }
            
            showDebugInfo('è½¬æ¢æ—¥å¿—', conversionLog)
            return convertedData
        }
        
        /**
         * å¤„ç†RPEæ ¼å¼éŸ³ç¬¦
         */
        function processRPENotes(notesArray, targetType, includeHold, holdMinLengthSec, lineIndex, log) {
            let converted = 0
            let skipped = 0
            
            notesArray.forEach((note, index) => {
                // è·³è¿‡å‡éŸ³ç¬¦
                if (note.isFake === 1) {
                    skipped++
                    if (index < 2) log.push(`  è·³è¿‡å‡éŸ³ç¬¦ ${index+1}`)
                    return
                }
                
                const originalType = note.type || 1
                const timeInfo = bpmProcessor.parseNoteTime(note, lineIndex)
                
                // è§„åˆ™1ï¼šæœªå‹¾é€‰åŒ…å«Holdï¼Œä¸”åŸç±»å‹æ˜¯Holdï¼ˆ2ï¼‰â†’ è·³è¿‡
                if (originalType === 2 && !includeHold) {
                    skipped++
                    if (index < 2) log.push(`  è·³è¿‡HoldéŸ³ç¬¦ ${index+1} (ä¿ç•™åŸç±»å‹)`)
                    return
                }
                
                // è§„åˆ™2ï¼šå·²ç»æ˜¯ç›®æ ‡ç±»å‹ â†’ è·³è¿‡
                if (originalType === targetType) {
                    return
                }
                
                // è§„åˆ™3ï¼šè½¬æ¢ä¸ºç›®æ ‡ç±»å‹
                converted++
                const originalTypeName = getTypeName(originalType, 'rpe')
                const targetTypeName = getTypeName(targetType, 'rpe')
                
                // è®°å½•è½¬æ¢ä¿¡æ¯
                if (index < 2) {
                    log.push(`  éŸ³ç¬¦ ${index+1}: ${originalTypeName}(${originalType}) â†’ ${targetTypeName}(${targetType})`)
                    log.push(`    åŸæ—¶é—´: ${timeInfo.startTimeBeat.toFixed(2)} â†’ ${timeInfo.endTimeBeat.toFixed(2)} (${timeInfo.durationSec.toFixed(3)}s)`)
                }
                
                // ä¿®æ”¹ç±»å‹
                note.type = targetType
                
                // å¤„ç†Holdç›¸å…³å±æ€§
                if (targetType === 2) { // è½¬æ¢ä¸ºHold
                    // è®¾ç½®endTimeï¼ˆåŸºäºæœ€å°é•¿åº¦ï¼‰
                    const minEndBeat = bpmProcessor.sec2beat(
                        timeInfo.startSec + holdMinLengthSec,
                        lineIndex
                    )
                    note.startTime = Array.isArray(note.startTime) ? note.startTime : [0, Math.round(timeInfo.startTimeBeat * 48), 48]
                    note.endTime = [0, Math.round(minEndBeat * 48), 48]
                    
                    // ç¡®ä¿Holdçš„å¿…è¦å±æ€§
                    if (note.above === undefined) note.above = 1
                    if (note.visibleTime === undefined) note.visibleTime = 999999.0
                    
                    if (index < 2) {
                        log.push(`    æ–°æ—¶é—´: ${timeInfo.startTimeBeat.toFixed(2)} â†’ ${minEndBeat.toFixed(2)} (${holdMinLengthSec}s)`)
                    }
                } else { // è½¬æ¢ä¸ºéHoldç±»å‹
                    // ç»Ÿä¸€startTimeå’ŒendTime
                    note.endTime = note.startTime
                    // ç§»é™¤Holdç›¸å…³å±æ€§ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if (note.hasOwnProperty('holdTime')) delete note.holdTime
                }
                
                // ä¿ç•™åŸæœ‰å­—æ®µï¼ˆå…¼å®¹tint/colorç­‰ï¼‰
                if (note.color && !note.tint) note.tint = note.color
            })
            
            log.push(`  ç»“æœï¼šè½¬æ¢${converted}ä¸ªï¼Œè·³è¿‡${skipped}ä¸ª`)
            return { converted, skipped }
        }
        
        /**
         * å¤„ç†å®˜æ–¹æ ¼å¼éŸ³ç¬¦
         */
        function processPhiNotes(notesArray, targetType, includeHold, holdMinLengthSec, log) {
            let converted = 0
            let skipped = 0
            
            // å®˜æ–¹æ ¼å¼çš„BPMï¼ˆç”¨äºæ—¶é—´è½¬æ¢ï¼‰
            const bpm = bpmProcessor.bpmList[0]?.bpm || 120
            const secPerUnit = 1.875 / bpm
            const minHoldUnits = holdMinLengthSec / secPerUnit
            
            notesArray.forEach((note, index) => {
                const originalType = note.type || 1
                const timeInfo = bpmProcessor.parseNoteTime(note)
                
                // è§„åˆ™1ï¼šæœªå‹¾é€‰åŒ…å«Holdï¼Œä¸”åŸç±»å‹æ˜¯Holdï¼ˆ3ï¼‰â†’ è·³è¿‡
                if (originalType === 3 && !includeHold) {
                    skipped++
                    if (index < 2) log.push(`  è·³è¿‡HoldéŸ³ç¬¦ ${index+1} (ä¿ç•™åŸç±»å‹)`)
                    return
                }
                
                // è§„åˆ™2ï¼šå·²ç»æ˜¯ç›®æ ‡ç±»å‹ â†’ è·³è¿‡
                if (originalType === targetType) {
                    return
                }
                
                // è§„åˆ™3ï¼šè½¬æ¢ä¸ºç›®æ ‡ç±»å‹
                converted++
                const originalTypeName = getTypeName(originalType, 'phi')
                const targetTypeName = getTypeName(targetType, 'phi')
                
                // è®°å½•è½¬æ¢ä¿¡æ¯
                if (index < 2) {
                    log.push(`  éŸ³ç¬¦ ${index+1}: ${originalTypeName}(${originalType}) â†’ ${targetTypeName}(${targetType})`)
                    log.push(`    åŸæ—¶é—´: ${note.time.toFixed(3)} (${timeInfo.startSec.toFixed(3)}s)ï¼ŒåŸæŒç»­: ${note.holdTime.toFixed(3)}`)
                }
                
                // ä¿®æ”¹ç±»å‹
                note.type = targetType
                
                // å¤„ç†Holdç›¸å…³å±æ€§
                if (targetType === 3) { // è½¬æ¢ä¸ºHold
                    note.holdTime = minHoldUnits
                    if (index < 2) {
                        log.push(`    æ–°æŒç»­: ${minHoldUnits.toFixed(3)} (${holdMinLengthSec}s)`)
                    }
                } else { // è½¬æ¢ä¸ºéHoldç±»å‹
                    note.holdTime = 0.0
                }
                
                // ä¿ç•™åŸæœ‰å­—æ®µ
                if (note.positionX === undefined) note.positionX = 0
                if (note.speed === undefined) note.speed = 1.0
            })
            
            log.push(`  ç»“æœï¼šè½¬æ¢${converted}ä¸ªï¼Œè·³è¿‡${skipped}ä¸ª`)
            return { converted, skipped }
        }
        
        /**
         * ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶
         */
        async function downloadConvertedZip() {
            if (!originalZip || !chartData) {
                showStatus('è¯·å…ˆä¸Šä¼ ZIPæ–‡ä»¶', 'error')
                return
            }
            
            downloadBtn.textContent = 'å¤„ç†ä¸­...'
            downloadBtn.disabled = true
            
            try {
                // æ‰§è¡Œè½¬æ¢
                const convertedData = convertChartData()
                if (!convertedData) {
                    throw new Error('è°±é¢è½¬æ¢å¤±è´¥')
                }
                
                // éªŒè¯è½¬æ¢ç»“æœ
                const validationLog = [`=== è½¬æ¢ç»“æœéªŒè¯ ===`]
                const finalNoteCount = countNotes(convertedData, chartFormat)
                validationLog.push(`æ ¼å¼: ${chartFormat === 'rpe' ? 'RPE' : 'å®˜æ–¹æ ¼å¼(phi)'}`)
                validationLog.push(`è½¬æ¢åæ€»éŸ³ç¬¦æ•°: ${finalNoteCount}`)
                validationLog.push(`ç›®æ ‡ç±»å‹: ${selectedType} (${TYPE_MAPPING[chartFormat][selectedType]})`)
                validationLog.push('')
                
                // æ£€æŸ¥è½¬æ¢åçš„ç±»å‹åˆ†å¸ƒ
                if (chartFormat === 'rpe' && convertedData.judgeLineList && convertedData.judgeLineList[0]) {
                    const firstLine = convertedData.judgeLineList[0]
                    const notes = firstLine.notesAbove || firstLine.notesBelow || []
                    if (notes.length > 0) {
                        const typeCount = countNoteTypes(notes.slice(0, 50), chartFormat)
                        validationLog.push('å‰50ä¸ªéŸ³ç¬¦ç±»å‹åˆ†å¸ƒ:')
                        for (const [type, count] of Object.entries(typeCount)) {
                            validationLog.push(`  ${getTypeName(type, chartFormat)}: ${count} ä¸ª`)
                        }
                    }
                } else if (chartFormat === 'phi' && convertedData.noteList && convertedData.noteList.length > 0) {
                    const typeCount = countNoteTypes(convertedData.noteList.slice(0, 50), chartFormat)
                    validationLog.push('å‰50ä¸ªéŸ³ç¬¦ç±»å‹åˆ†å¸ƒ:')
                    for (const [type, count] of Object.entries(typeCount)) {
                        validationLog.push(`  ${getTypeName(type, chartFormat)}: ${count} ä¸ª`)
                    }
                }
                
                showDebugInfo('è½¬æ¢éªŒè¯', validationLog)
                
                // ç”Ÿæˆæ–°ZIPæ–‡ä»¶
                const modifiedZip = new JSZip()
                
                // å¤åˆ¶åŸæœ‰æ–‡ä»¶å¹¶æ›¿æ¢è°±é¢JSON
                const promises = []
                originalZip.forEach((relativePath, file) => {
                    if (!file.dir) {
                        promises.push(
                            file.async('uint8array').then(content => {
                                if (relativePath === jsonFileName) {
                                    // æ›¿æ¢ä¸ºè½¬æ¢åçš„JSON
                                    modifiedZip.file(relativePath, JSON.stringify(convertedData, null, 2))
                                } else {
                                    // å…¶ä»–æ–‡ä»¶åŸæ ·ä¿ç•™
                                    modifiedZip.file(relativePath, content)
                                }
                            })
                        )
                    }
                })
                
                await Promise.all(promises)
                
                // ç”ŸæˆZIP Blob
                const zipBlob = await modifiedZip.generateAsync({
                    type: 'blob',
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                })
                
                // ä¸‹è½½æ–‡ä»¶
                const url = URL.createObjectURL(zipBlob)
                const a = document.createElement('a')
                a.href = url
                a.download = `${originalFileName}_${selectedType}_${chartFormat.toUpperCase()}.zip`
                document.body.appendChild(a)
                a.click()
                document.body.removeChild(a)
                URL.revokeObjectURL(url)
                
                showStatus(`ä¸‹è½½æˆåŠŸï¼è½¬æ¢åå…±${finalNoteCount}ä¸ªéŸ³ç¬¦`, 'success')
                
            } catch (error) {
                showStatus(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'error')
                showDebugInfo('ä¸‹è½½é”™è¯¯', [
                    `é”™è¯¯ä¿¡æ¯: ${error.message}`,
                    `é”™è¯¯å †æ ˆ: ${error.stack ? error.stack.substring(0, 500) + '...' : 'æ— '}`
                ])
            } finally {
                downloadBtn.textContent = 'ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶'
                downloadBtn.disabled = false
            }
        }
        
        /**
         * æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
         */
        function showDebugInfo(title, content) {
            const timeStr = new Date().toLocaleTimeString()
            const section = document.createElement('div')
            section.style.marginBottom = '15px'
            section.innerHTML = `<strong>${timeStr} - ${title}:</strong><br>`
            
            if (Array.isArray(content)) {
                content.forEach(line => {
                    section.innerHTML += line + '<br>'
                })
            } else if (typeof content === 'object') {
                for (const [key, value] of Object.entries(content)) {
                    section.innerHTML += `${key}: ${value}<br>`
                }
            } else {
                section.innerHTML += content
            }
            
            debugContent.appendChild(section)
            debugInfo.scrollTop = debugInfo.scrollHeight
        }
        
        /**
         * æ˜¾ç¤ºçŠ¶æ€æç¤º
         */
        function showStatus(message, type = 'success') {
            status.textContent = message
            status.className = `status show ${type}`
            setTimeout(() => status.classList.remove('show'), 5000)
        }
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init)
    </script>
</body>
</html>