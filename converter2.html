<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhigrosæŒ‰é”®è½¬æ¢å™¨</title>
    <link rel="stylesheet" href="common.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>PhigrosæŒ‰é”®è½¬æ¢å™¨</h1>
        </header>
        
        <div class="main-content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <p>ä¸Šä¼ Phigrosè°±é¢ZIPæ–‡ä»¶</p>
                <input type="file" id="fileInput" accept=".zip">
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>å¤„ç†ä¸­...</p>
            </div>
            
            <div class="controls-section" id="controlsSection">
                <div class="file-info" id="fileInfo">
                    <div class="info-item">
                        <span>æ–‡ä»¶:</span>
                        <span id="fileName">-</span>
                    </div>
                    <div class="info-item">
                        <span>æŒ‰é”®æ•°:</span>
                        <span id="noteCount">-</span>
                    </div>
                    <div class="info-item">
                        <span>æ ¼å¼:</span>
                        <span id="chartFormat">-</span>
                    </div>
                    <div class="info-item">
                        <span>formatVersion:</span>
                        <span id="formatVersion">-</span>
                    </div>
                    <div class="info-item">
                        <span>åˆ¤å®šçº¿æ•°:</span>
                        <span id="judgeLineCount">-</span>
                    </div>
                </div>
                
                <div class="conversion-controls">
                    <div class="conversion-options">
                        <button class="conversion-btn" data-type="tap">Tap</button>
                        <button class="conversion-btn" data-type="drag">Drag</button>
                        <button class="conversion-btn" data-type="hold">Hold</button>
                        <button class="conversion-btn" data-type="flick">Flick</button>
                    </div>
                    
                    <div class="hold-controls" id="holdControls">
                        <div class="hold-option">
                            <input type="checkbox" id="includeHold" checked>
                            <label for="includeHold">åŒ…å«HoldæŒ‰é”®</label>
                        </div>
                        <div class="hold-length" id="holdLengthControl">
                            <label>æœ€å°é•¿åº¦:</label>
                            <input type="number" id="holdLength" value="200" min="50" max="1000">
                            <span>ms</span>
                        </div>
                    </div>
                </div>
                
                <button class="download-btn" id="downloadBtn" disabled>
                    ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶
                </button>
                
                <div class="status" id="status"></div>
                
                <div class="debug-info" id="debugInfo" style="display: none; margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 12px;">
                    <h4 style="margin-bottom: 10px;">è°ƒè¯•ä¿¡æ¯</h4>
                    <div id="debugContent"></div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>æœ¬å·¥å…·å®Œå…¨åœ¨æµè§ˆå™¨ä¸­è¿è¡Œï¼Œä¸ä¼šä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨</p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let originalZip = null;
        let jsonFileName = null;
        let chartData = null;
        let chartFormat = null; // 'rpe' æˆ– 'phi'
        let selectedType = 'tap';
        let originalFileName = '';

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const loading = document.getElementById('loading');
        const controlsSection = document.getElementById('controlsSection');
        const downloadBtn = document.getElementById('downloadBtn');
        const status = document.getElementById('status');
        const holdControls = document.getElementById('holdControls');
        const holdLengthControl = document.getElementById('holdLengthControl');
        const includeHoldCheck = document.getElementById('includeHold');
        const holdLengthInput = document.getElementById('holdLength');

        const fileNameSpan = document.getElementById('fileName');
        const noteCountSpan = document.getElementById('noteCount');
        const chartFormatSpan = document.getElementById('chartFormat');
        const formatVersionSpan = document.getElementById('formatVersion');
        const judgeLineCountSpan = document.getElementById('judgeLineCount');
        const debugInfo = document.getElementById('debugInfo');
        const debugContent = document.getElementById('debugContent');

        function init() {
            uploadArea.addEventListener('click', () => fileInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#3498db';
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '#bdc3c7';
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#bdc3c7';
                if (e.dataTransfer.files.length) {
                    handleFileUpload(e.dataTransfer.files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    handleFileUpload(e.target.files[0]);
                }
            });
            
            document.querySelectorAll('.conversion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.conversion-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedType = this.dataset.type;
                    
                    if (selectedType === 'hold') {
                        holdLengthControl.style.display = 'flex';
                        includeHoldCheck.style.display = 'none';
                    } else {
                        holdLengthControl.style.display = 'none';
                        includeHoldCheck.style.display = 'flex';
                    }
                });
            });
            
            document.querySelector('.conversion-btn[data-type="tap"]').click();
            
            downloadBtn.addEventListener('click', downloadConvertedZip);
        }

        function getTypeValue(type) {
            const values = { tap: 1, drag: 2, hold: 3, flick: 4 };
            return values[type] || 1;
        }

        /**
         * ä¸¥æ ¼åˆ¤æ–­è°±é¢æ ¼å¼
         * @param {Object} data - è§£æåçš„JSONæ•°æ®
         * @returns {'rpe'|'phi'|'unknown'} æ ¼å¼ç±»å‹
         */
        function determineChartFormat(data) {
            // éªŒè¯RPEæ ¼å¼ï¼šå¿…é¡»å­˜åœ¨judgeLineListä¸”ä¸ºæ•°ç»„
            if (data.judgeLineList && Array.isArray(data.judgeLineList)) {
                // è¿›ä¸€æ­¥éªŒè¯ï¼šRPEæ ¼å¼çš„åˆ¤å®šçº¿åº”è¯¥æœ‰notesAbove/notesBelowå±æ€§
                if (data.judgeLineList.length > 0) {
                    const firstLine = data.judgeLineList[0];
                    // å¦‚æœæœ‰bpmListï¼Œå¾ˆå¯èƒ½æ˜¯RPE
                    if (data.bpmList && Array.isArray(data.bpmList)) {
                        return 'rpe';
                    }
                    // æ£€æŸ¥notesAbove/notesBelowæ˜¯å¦å­˜åœ¨
                    if (firstLine.hasOwnProperty('notesAbove') || firstLine.hasOwnProperty('notesBelow')) {
                        return 'rpe';
                    }
                    // æ£€æŸ¥versionå­—æ®µ
                    if (data.formatVersion && data.formatVersion.toString().includes('rpe')) {
                        return 'rpe';
                    }
                }
            }
            
            // éªŒè¯å®˜æ–¹æ ¼å¼ï¼šå¿…é¡»å­˜åœ¨noteListä¸”ä¸ºæ•°ç»„
            if (data.noteList && Array.isArray(data.noteList)) {
                // éªŒè¯noteç»“æ„
                if (data.noteList.length > 0) {
                    const firstNote = data.noteList[0];
                    // å®˜æ–¹æ ¼å¼çš„noteå¿…é¡»æœ‰type, time, judgeLineå±æ€§
                    if (firstNote.hasOwnProperty('type') && 
                        firstNote.hasOwnProperty('time') && 
                        firstNote.hasOwnProperty('judgeLine')) {
                        return 'phi';
                    }
                }
            }
            
            return 'unknown';
        }

        async function handleFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.zip')) {
                showStatus('è¯·ä¸Šä¼ ZIPæ–‡ä»¶', 'error');
                return;
            }
            
            loading.classList.add('show');
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                originalZip = await JSZip.loadAsync(arrayBuffer);
                
                originalFileName = file.name.replace(/\.zip$/i, '');
                
                const jsonFiles = [];
                originalZip.forEach((relativePath, fileEntry) => {
                    if (!fileEntry.dir && relativePath.toLowerCase().endsWith('.json')) {
                        jsonFiles.push(relativePath);
                    }
                });
                
                if (jsonFiles.length === 0) {
                    throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°JSONæ–‡ä»¶');
                }
                
                jsonFileName = jsonFiles[0];
                
                const jsonFile = originalZip.file(jsonFileName);
                if (!jsonFile) {
                    throw new Error('æ— æ³•è¯»å–JSONæ–‡ä»¶');
                }
                
                const jsonText = await jsonFile.async('text');
                chartData = JSON.parse(jsonText);
                
                // ç¡®å®šè°±é¢æ ¼å¼
                chartFormat = determineChartFormat(chartData);
                if (chartFormat === 'unknown') {
                    throw new Error('æ— æ³•è¯†åˆ«çš„è°±é¢æ ¼å¼ã€‚è¯·ç¡®ä¿æ˜¯RPEæˆ–å®˜æ–¹æ ¼å¼çš„è°±é¢æ–‡ä»¶ã€‚');
                }
                
                // æ˜¾ç¤ºè¯¦ç»†çš„è°±é¢ä¿¡æ¯
                const noteCount = countNotes(chartData, chartFormat);
                const judgeLineCount = getJudgeLineCount(chartData, chartFormat);
                
                fileNameSpan.textContent = file.name;
                noteCountSpan.textContent = noteCount;
                chartFormatSpan.textContent = chartFormat === 'rpe' ? 'RPE' : 'å®˜æ–¹æ ¼å¼';
                formatVersionSpan.textContent = chartData.formatVersion || '--';
                judgeLineCountSpan.textContent = judgeLineCount;
                
                // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                showDebugInfo('åŸå§‹è°±é¢åŠ è½½æˆåŠŸ', {
                    'æ–‡ä»¶å': file.name,
                    'è°±é¢æ ¼å¼': chartFormat === 'rpe' ? 'RPE' : 'å®˜æ–¹æ ¼å¼',
                    'formatVersion': chartData.formatVersion || '--',
                    'åˆ¤å®šçº¿æ•°é‡': judgeLineCount,
                    'æ€»æŒ‰é”®æ•°': noteCount,
                    'JSONæ–‡ä»¶': jsonFileName
                });
                
                // åˆ†æè°±é¢ç»“æ„
                analyzeChartStructure(chartData, chartFormat);
                
                controlsSection.classList.add('show');
                debugInfo.style.display = 'block';
                downloadBtn.disabled = false;
                
                showStatus('æˆåŠŸåŠ è½½è°±é¢', 'success');
                
            } catch (error) {
                showStatus('å¤„ç†å¤±è´¥: ' + error.message, 'error');
                showDebugInfo('åŠ è½½å¤±è´¥', { 'é”™è¯¯': error.message });
            } finally {
                loading.classList.remove('show');
            }
        }

        /**
         * æ ¹æ®ä¸åŒæ ¼å¼è®¡æ•°éŸ³ç¬¦
         * RPE: éŸ³ç¬¦åˆ†å¸ƒåœ¨judgeLineList[].notesAbove/Belowä¸­
         * å®˜æ–¹: éŸ³ç¬¦åœ¨noteListä¸­
         */
        function countNotes(chartData, format) {
            if (format === 'rpe') {
                let count = 0;
                if (chartData.judgeLineList) {
                    chartData.judgeLineList.forEach(line => {
                        if (line.notesAbove && Array.isArray(line.notesAbove)) {
                            count += line.notesAbove.length;
                        }
                        if (line.notesBelow && Array.isArray(line.notesBelow)) {
                            count += line.notesBelow.length;
                        }
                    });
                }
                return count;
            } else if (format === 'phi') {
                return chartData.noteList && Array.isArray(chartData.noteList) ? chartData.noteList.length : 0;
            }
            return 0;
        }

        /**
         * è·å–åˆ¤å®šçº¿æ•°é‡
         */
        function getJudgeLineCount(chartData, format) {
            if (format === 'rpe') {
                return chartData.judgeLineList && Array.isArray(chartData.judgeLineList) ? chartData.judgeLineList.length : 0;
            } else if (format === 'phi') {
                return chartData.judgeLineList && Array.isArray(chartData.judgeLineList) ? chartData.judgeLineList.length : 0;
            }
            return 0;
        }

        /**
         * åˆ†æè°±é¢ç»“æ„ï¼Œæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
         */
        function analyzeChartStructure(chartData, format) {
            const structureInfo = [];
            
            if (format === 'rpe') {
                structureInfo.push('=== RPEæ ¼å¼è°±é¢ç»“æ„åˆ†æ ===');
                
                if (!chartData.judgeLineList || !Array.isArray(chartData.judgeLineList)) {
                    structureInfo.push('âŒ æœªæ‰¾åˆ°judgeLineListæˆ–ä¸æ˜¯æ•°ç»„');
                    return;
                }
                
                // æ˜¾ç¤ºBPMä¿¡æ¯
                if (data.bpmList && Array.isArray(data.bpmList)) {
                    structureInfo.push(`âœ“ BPMåˆ—è¡¨: ${data.bpmList.length} ä¸ªèŠ‚æ‹ç‚¹`);
                }
                
                chartData.judgeLineList.forEach((line, lineIndex) => {
                    structureInfo.push(`\nåˆ¤å®šçº¿ ${lineIndex + 1}:`);
                    
                    // ç»Ÿè®¡è¯¥åˆ¤å®šçº¿çš„éŸ³ç¬¦
                    let aboveCount = 0, belowCount = 0;
                    if (line.notesAbove && Array.isArray(line.notesAbove)) {
                        aboveCount = line.notesAbove.length;
                        structureInfo.push(`  âœ“ notesAbove: ${aboveCount} ä¸ªæŒ‰é”®`);
                    }
                    if (line.notesBelow && Array.isArray(line.notesBelow)) {
                        belowCount = line.notesBelow.length;
                        structureInfo.push(`  âœ“ notesBelow: ${belowCount} ä¸ªæŒ‰é”®`);
                    }
                    
                    if (aboveCount === 0 && belowCount === 0) {
                        structureInfo.push(`  âŒ è¯¥åˆ¤å®šçº¿ä¸Šæ²¡æœ‰æ‰¾åˆ°æŒ‰é”®`);
                    }
                    
                    // æ˜¾ç¤ºå‰å‡ ä¸ªéŸ³ç¬¦çš„è¯¦æƒ…
                    const allNotes = [];
                    if (line.notesAbove) allNotes.push(...line.notesAbove.map(n => ({...n, position: 'Above'})));
                    if (line.notesBelow) allNotes.push(...line.notesBelow.map(n => ({...n, position: 'Below'})));
                    
                    allNotes.slice(0, 3).forEach((note, i) => {
                        structureInfo.push(`    éŸ³ç¬¦${i+1}: type=${getTypeName(note.type)}, time=${note.time.toFixed(2)}, pos=${note.position}`);
                    });
                    if (allNotes.length > 3) {
                        structureInfo.push(`    ... è¿˜æœ‰ ${allNotes.length - 3} ä¸ªéŸ³ç¬¦`);
                    }
                });
            } else if (format === 'phi') {
                structureInfo.push('=== å®˜æ–¹æ ¼å¼è°±é¢ç»“æ„åˆ†æ ===');
                
                // æ£€æŸ¥åˆ¤å®šçº¿
                if (!chartData.judgeLineList || !Array.isArray(chartData.judgeLineList)) {
                    structureInfo.push('âŒ æœªæ‰¾åˆ°judgeLineList');
                } else {
                    structureInfo.push(`âœ“ åˆ¤å®šçº¿åˆ—è¡¨: ${chartData.judgeLineList.length} æ¡`);
                }
                
                // æ£€æŸ¥éŸ³ç¬¦åˆ—è¡¨
                if (!chartData.noteList || !Array.isArray(chartData.noteList)) {
                    structureInfo.push('âŒ æœªæ‰¾åˆ°noteList');
                } else {
                    const noteCount = chartData.noteList.length;
                    structureInfo.push(`âœ“ éŸ³ç¬¦åˆ—è¡¨: ${noteCount} ä¸ªéŸ³ç¬¦`);
                    
                    // æŒ‰åˆ¤å®šçº¿åˆ†ç»„ç»Ÿè®¡
                    const notesByLine = {};
                    chartData.noteList.forEach(note => {
                        const lineId = note.judgeLine;
                        if (!notesByLine[lineId]) notesByLine[lineId] = [];
                        notesByLine[lineId].push(note);
                    });
                    
                    Object.keys(notesByLine).sort((a,b) => parseInt(a)-parseInt(b)).forEach(lineId => {
                        const notes = notesByLine[lineId];
                        structureInfo.push(`  åˆ¤å®šçº¿ ${lineId}: ${notes.length} ä¸ªéŸ³ç¬¦`);
                        
                        // æ˜¾ç¤ºå‰å‡ ä¸ª
                        notes.slice(0, 2).forEach((note, i) => {
                            structureInfo.push(`    éŸ³ç¬¦${i+1}: type=${getTypeName(note.type)}, time=${note.time.toFixed(2)}`);
                        });
                    });
                }
            }
            
            showDebugInfo('è°±é¢ç»“æ„åˆ†æ', structureInfo);
        }

        /**
         * è·å–éŸ³ç¬¦ç±»å‹åç§°
         */
        function getTypeName(typeValue) {
            const typeMap = { 1: 'Tap', 2: 'Drag', 3: 'Hold', 4: 'Flick' };
            return typeMap[typeValue] || `Unknown(${typeValue})`;
        }

        /**
         * æ ¸å¿ƒè½¬æ¢å‡½æ•°ï¼šæ ¹æ®æ ¼å¼ç±»å‹åº”ç”¨ä¸åŒçš„è½¬æ¢é€»è¾‘
         */
        function convertChartData() {
            if (!chartData || !chartFormat) return null;

            // æ·±æ‹·è´åŸå§‹æ•°æ®
            const convertedData = JSON.parse(JSON.stringify(chartData));
            const targetTypeValue = getTypeValue(selectedType);
            const includeHold = includeHoldCheck.checked;
            const holdMinLength = parseInt(holdLengthInput.value) || 200;

            let totalConverted = 0;
            let totalSkipped = 0;
            const conversionLog = [`=== å¼€å§‹è½¬æ¢: ç›®æ ‡ç±»å‹=${getTypeName(targetTypeValue)} ===`];

            if (chartFormat === 'rpe') {
                conversionLog.push('\n--- å¤„ç†RPEæ ¼å¼ ---');
                
                if (!convertedData.judgeLineList || !Array.isArray(convertedData.judgeLineList)) {
                    throw new Error('RPEæ ¼å¼é”™è¯¯: ç¼ºå°‘judgeLineList');
                }

                convertedData.judgeLineList.forEach((judgeLine, lineIndex) => {
                    conversionLog.push(`\nåˆ¤å®šçº¿ ${lineIndex + 1}:`);
                    
                    // å¤„ç†ä¸Šæ–¹éŸ³ç¬¦
                    if (judgeLine.notesAbove && Array.isArray(judgeLine.notesAbove)) {
                        conversionLog.push(`  notesAbove: ${judgeLine.notesAbove.length} ä¸ª`);
                        const result = processNotesArray(
                            judgeLine.notesAbove, 
                            targetTypeValue, 
                            includeHold, 
                            holdMinLength, 
                            conversionLog,
                            '    '
                        );
                        totalConverted += result.converted;
                        totalSkipped += result.skipped;
                    }
                    
                    // å¤„ç†ä¸‹æ–¹éŸ³ç¬¦
                    if (judgeLine.notesBelow && Array.isArray(judgeLine.notesBelow)) {
                        conversionLog.push(`  notesBelow: ${judgeLine.notesBelow.length} ä¸ª`);
                        const result = processNotesArray(
                            judgeLine.notesBelow, 
                            targetTypeValue, 
                            includeHold, 
                            holdMinLength, 
                            conversionLog,
                            '    '
                        );
                        totalConverted += result.converted;
                        totalSkipped += result.skipped;
                    }
                });
            } else if (chartFormat === 'phi') {
                conversionLog.push('\n--- å¤„ç†å®˜æ–¹æ ¼å¼ ---');
                
                if (!convertedData.noteList || !Array.isArray(convertedData.noteList)) {
                    throw new Error('å®˜æ–¹æ ¼å¼é”™è¯¯: ç¼ºå°‘noteList');
                }

                conversionLog.push(`noteList: ${convertedData.noteList.length} ä¸ªéŸ³ç¬¦`);
                const result = processNotesArray(
                    convertedData.noteList,
                    targetTypeValue,
                    includeHold,
                    holdMinLength,
                    conversionLog,
                    '  '
                );
                totalConverted += result.converted;
                totalSkipped += result.skipped;
            }

            conversionLog.push(`\n=== è½¬æ¢å®Œæˆ ===`);
            conversionLog.push(`æ€»è®¡: è½¬æ¢äº† ${totalConverted} ä¸ª, è·³è¿‡äº† ${totalSkipped} ä¸ª`);
            
            // æ›´æ–°numOfNoteså­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (convertedData.numOfNotes !== undefined) {
                const finalNoteCount = countNotes(convertedData, chartFormat);
                convertedData.numOfNotes = finalNoteCount;
                conversionLog.push(`æ›´æ–°äº† numOfNotes: ${finalNoteCount}`);
            }

            showDebugInfo('è½¬æ¢è¿‡ç¨‹è¯¦æƒ…', conversionLog);
            return convertedData;
        }

        /**
         * å¤„ç†éŸ³ç¬¦æ•°ç»„ï¼ˆé€šç”¨é€»è¾‘ï¼‰
         * @param {Array} notesArray - éŸ³ç¬¦æ•°ç»„
         * @param {number} targetType - ç›®æ ‡ç±»å‹å€¼
         * @param {boolean} includeHold - æ˜¯å¦åŒ…å«Hold
         * @param {number} holdMinLength - Holdæœ€å°é•¿åº¦
         * @param {Array} log - æ—¥å¿—æ•°ç»„
         * @param {string} indent - æ—¥å¿—ç¼©è¿›
         * @returns {Object} {converted, skipped}
         */
        function processNotesArray(notesArray, targetType, includeHold, holdMinLength, log, indent = '') {
            let converted = 0;
            let skipped = 0;
            
            // é¢„æ‰«æç»Ÿè®¡
            const typeStats = {};
            notesArray.forEach(note => {
                typeStats[note.type] = (typeStats[note.type] || 0) + 1;
            });
            
            log.push(`${indent}åŸå§‹åˆ†å¸ƒ: ${Object.entries(typeStats).map(([t,c]) => `${getTypeName(parseInt(t))}:${c}`).join(', ')}`);
            
            // å¤„ç†æ¯ä¸ªéŸ³ç¬¦
            notesArray.forEach((note, index) => {
                const originalType = note.type;
                
                // è·³è¿‡æ¡ä»¶ï¼šæ˜¯Holdä¸”æœªå‹¾é€‰åŒ…å«Hold
                if (originalType === 3 && !includeHold) {
                    skipped++;
                    return;
                }
                
                // æ— éœ€è½¬æ¢ï¼šå·²ç»æ˜¯ç›®æ ‡ç±»å‹
                if (originalType === targetType) {
                    return;
                }
                
                // æ‰§è¡Œè½¬æ¢
                converted++;
                
                // Holdç‰¹æ®Šå¤„ç†
                if (targetType === 3) { // è½¬æ¢ä¸ºHold
                    // RPEå’Œå®˜æ–¹æ ¼å¼çš„Holdéƒ½ä½¿ç”¨holdTime
                    note.holdTime = holdMinLength;
                } else { // è½¬æ¢éHold
                    // ç§»é™¤holdTimeå±æ€§ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if (note.hasOwnProperty('holdTime')) {
                        delete note.holdTime;
                    }
                }
                
                // ä¿®æ”¹ç±»å‹
                note.type = targetType;
                
                // è®°å½•å‰å‡ ä¸ªè½¬æ¢è¯¦æƒ…
                if (converted <= 3) {
                    log.push(`${indent}  è½¬æ¢: ${getTypeName(originalType)} -> ${getTypeName(targetType)} (time=${note.time.toFixed(2)})`);
                }
            });
            
            // åæ‰«æç»Ÿè®¡
            const finalStats = {};
            notesArray.forEach(note => {
                finalStats[note.type] = (finalStats[note.type] || 0) + 1;
            });
            log.push(`${indent}è½¬æ¢ååˆ†å¸ƒ: ${Object.entries(finalStats).map(([t,c]) => `${getTypeName(parseInt(t))}:${c}`).join(', ')}`);
            
            return { converted, skipped };
        }

        /**
         * ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶
         */
        async function downloadConvertedZip() {
            if (!originalZip || !chartData) {
                showStatus('è¯·å…ˆä¸Šä¼ ZIPæ–‡ä»¶', 'error');
                return;
            }
            
            if (!chartFormat) {
                showStatus('æœªçŸ¥çš„è°±é¢æ ¼å¼', 'error');
                return;
            }
            
            downloadBtn.textContent = 'å¤„ç†ä¸­...';
            downloadBtn.disabled = true;
            
            try {
                const convertedData = convertChartData();
                if (!convertedData) {
                    throw new Error('è½¬æ¢å¤±è´¥');
                }
                
                // éªŒè¯è½¬æ¢ç»“æœ
                const validationLog = ['=== è½¬æ¢éªŒè¯ ==='];
                const finalNoteCount = countNotes(convertedData, chartFormat);
                validationLog.push(`æ€»éŸ³ç¬¦æ•°: ${finalNoteCount}`);
                
                // æ˜¾ç¤ºæ ¼å¼ç‰¹å®šä¿¡æ¯
                if (chartFormat === 'rpe') {
                    const lineWithNotes = convertedData.judgeLineList.filter(line => 
                        (line.notesAbove && line.notesAbove.length > 0) || 
                        (line.notesBelow && line.notesBelow.length > 0)
                    ).length;
                    validationLog.push(`æœ‰éŸ³ç¬¦çš„åˆ¤å®šçº¿: ${lineWithNotes}`);
                } else if (chartFormat === 'phi') {
                    const typeStats = {};
                    convertedData.noteList.forEach(note => {
                        typeStats[note.type] = (typeStats[note.type] || 0) + 1;
                    });
                    validationLog.push(`éŸ³ç¬¦åˆ†å¸ƒ: ${Object.entries(typeStats).map(([t,c]) => `${getTypeName(parseInt(t))}:${c}`).join(', ')}`);
                }
                
                showDebugInfo('è½¬æ¢éªŒè¯', validationLog);
                
                // åˆ›å»ºæ–°çš„ZIPæ–‡ä»¶
                const modifiedZip = new JSZip();
                const promises = [];
                
                originalZip.forEach((relativePath, file) => {
                    if (!file.dir) {
                        promises.push(
                            file.async('uint8array').then(content => {
                                if (relativePath === jsonFileName) {
                                    // ä½¿ç”¨ç´§å‡‘çš„JSONæ ¼å¼
                                    modifiedZip.file(relativePath, JSON.stringify(convertedData));
                                } else {
                                    modifiedZip.file(relativePath, content);
                                }
                            })
                        );
                    }
                });
                
                await Promise.all(promises);
                
                // ç”ŸæˆZIPæ–‡ä»¶
                const zipBlob = await modifiedZip.generateAsync({
                    type: 'blob',
                    compression: "DEFLATE",
                    compressionOptions: { level: 9 }
                });
                
                // ä¸‹è½½
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${originalFileName}_${selectedType}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus(`ä¸‹è½½æˆåŠŸï¼è½¬æ¢äº† ${finalNoteCount} ä¸ªéŸ³ç¬¦`, 'success');
                
            } catch (error) {
                showStatus('ä¸‹è½½å¤±è´¥: ' + error.message, 'error');
                showDebugInfo('ä¸‹è½½é”™è¯¯', { 'é”™è¯¯': error.message, 'å †æ ˆ': error.stack });
            } finally {
                downloadBtn.textContent = 'ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶';
                downloadBtn.disabled = false;
            }
        }

        /**
         * æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
         */
        function showDebugInfo(title, content) {
            debugContent.innerHTML = `<strong style="color: #2c3e50;">${title}:</strong><br>`;
            
            if (Array.isArray(content)) {
                content.forEach(line => {
                    debugContent.innerHTML += line + '<br>';
                });
            } else if (typeof content === 'object') {
                for (const [key, value] of Object.entries(content)) {
                    const displayValue = (typeof value === 'object') ? JSON.stringify(value) : value;
                    debugContent.innerHTML += `<span style="color: #34495e;">${key}:</span> <span style="color: #7f8c8d;">${displayValue}</span><br>`;
                }
            } else {
                debugContent.innerHTML += content;
            }
        }

        /**
         * æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
         */
        function showStatus(message, type = 'success') {
            status.textContent = message;
            status.className = `status show ${type}`;
            
            setTimeout(() => {
                status.classList.remove('show');
            }, 5000);
        }

        document.addEventListener('DOMContentLoaded', () => {
            init();
        });
    </script>
</body>
</html>